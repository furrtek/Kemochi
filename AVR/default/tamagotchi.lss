
tamagotchi.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a82  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  00000a82  00000b16  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000006b  00800062  00800062  00000b18  2**0
                  ALLOC
  3 .debug_aranges 00000060  00000000  00000000  00000b18  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000217  00000000  00000000  00000b78  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001354  00000000  00000000  00000d8f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000553  00000000  00000000  000020e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000f8a  00000000  00000000  00002636  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000001b0  00000000  00000000  000035c0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000024a  00000000  00000000  00003770  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000076a  00000000  00000000  000039ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001b0  00000000  00000000  00004124  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
   2:	84 c2       	rjmp	.+1288   	; 0x50c <__vector_1>
   4:	f7 c0       	rjmp	.+494    	; 0x1f4 <__vector_2>
   6:	f6 c0       	rjmp	.+492    	; 0x1f4 <__vector_2>
   8:	27 c0       	rjmp	.+78     	; 0x58 <__bad_interrupt>
   a:	26 c0       	rjmp	.+76     	; 0x58 <__bad_interrupt>
   c:	25 c0       	rjmp	.+74     	; 0x58 <__bad_interrupt>
   e:	24 c0       	rjmp	.+72     	; 0x58 <__bad_interrupt>
  10:	51 c0       	rjmp	.+162    	; 0xb4 <__vector_8>
  12:	22 c0       	rjmp	.+68     	; 0x58 <__bad_interrupt>
  14:	21 c0       	rjmp	.+66     	; 0x58 <__bad_interrupt>
  16:	20 c0       	rjmp	.+64     	; 0x58 <__bad_interrupt>
  18:	1f c0       	rjmp	.+62     	; 0x58 <__bad_interrupt>
  1a:	1e c0       	rjmp	.+60     	; 0x58 <__bad_interrupt>
  1c:	1d c0       	rjmp	.+58     	; 0x58 <__bad_interrupt>
  1e:	1c c0       	rjmp	.+56     	; 0x58 <__bad_interrupt>
  20:	1b c0       	rjmp	.+54     	; 0x58 <__bad_interrupt>

00000022 <__ctors_end>:
  22:	11 24       	eor	r1, r1
  24:	1f be       	out	0x3f, r1	; 63
  26:	cf e5       	ldi	r28, 0x5F	; 95
  28:	d1 e0       	ldi	r29, 0x01	; 1
  2a:	de bf       	out	0x3e, r29	; 62
  2c:	cd bf       	out	0x3d, r28	; 61

0000002e <__do_copy_data>:
  2e:	10 e0       	ldi	r17, 0x00	; 0
  30:	a0 e6       	ldi	r26, 0x60	; 96
  32:	b0 e0       	ldi	r27, 0x00	; 0
  34:	e2 e8       	ldi	r30, 0x82	; 130
  36:	fa e0       	ldi	r31, 0x0A	; 10
  38:	02 c0       	rjmp	.+4      	; 0x3e <.do_copy_data_start>

0000003a <.do_copy_data_loop>:
  3a:	05 90       	lpm	r0, Z+
  3c:	0d 92       	st	X+, r0

0000003e <.do_copy_data_start>:
  3e:	a2 36       	cpi	r26, 0x62	; 98
  40:	b1 07       	cpc	r27, r17
  42:	d9 f7       	brne	.-10     	; 0x3a <.do_copy_data_loop>

00000044 <__do_clear_bss>:
  44:	10 e0       	ldi	r17, 0x00	; 0
  46:	a2 e6       	ldi	r26, 0x62	; 98
  48:	b0 e0       	ldi	r27, 0x00	; 0
  4a:	01 c0       	rjmp	.+2      	; 0x4e <.do_clear_bss_start>

0000004c <.do_clear_bss_loop>:
  4c:	1d 92       	st	X+, r1

0000004e <.do_clear_bss_start>:
  4e:	ad 3c       	cpi	r26, 0xCD	; 205
  50:	b1 07       	cpc	r27, r17
  52:	e1 f7       	brne	.-8      	; 0x4c <.do_clear_bss_loop>
  54:	10 d1       	rcall	.+544    	; 0x276 <main>
  56:	13 c5       	rjmp	.+2598   	; 0xa7e <_exit>

00000058 <__bad_interrupt>:
  58:	d3 cf       	rjmp	.-90     	; 0x0 <__vectors>

0000005a <get_adc>:
#define SLEEP 1
#define FA 2

uint8_t get_adc() {
	uint8_t value;
	ADCSRA |= (1 << ADSC);
  5a:	36 9a       	sbi	0x06, 6	; 6
	while (ADCSRA & (1 << ADSC)); 
  5c:	36 99       	sbic	0x06, 6	; 6
  5e:	fe cf       	rjmp	.-4      	; 0x5c <get_adc+0x2>
	value = ADCH;
  60:	85 b1       	in	r24, 0x05	; 5
	ADCSRA |= (1 << ADSC);
  62:	36 9a       	sbi	0x06, 6	; 6
	while (ADCSRA & (1 << ADSC));
  64:	36 99       	sbic	0x06, 6	; 6
  66:	fe cf       	rjmp	.-4      	; 0x64 <get_adc+0xa>
	return ADCH;
  68:	85 b1       	in	r24, 0x05	; 5
}
  6a:	08 95       	ret

0000006c <selbeep>:
	drawlcd(60+7,5,18,9,v,0);
}

void selbeep() {
	uint8_t c;
	PCMSK1 = 0b00000010;
  6c:	82 e0       	ldi	r24, 0x02	; 2
  6e:	80 bd       	out	0x20, r24	; 32
	DDRB |= 1;
  70:	b8 9a       	sbi	0x17, 0	; 23
  72:	90 e0       	ldi	r25, 0x00	; 0
	for (c=0;c<64;c++) {
		PORTB ^= 1;
  74:	31 e0       	ldi	r19, 0x01	; 1
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
  76:	25 e8       	ldi	r18, 0x85	; 133
  78:	88 b3       	in	r24, 0x18	; 24
  7a:	83 27       	eor	r24, r19
  7c:	88 bb       	out	0x18, r24	; 24
  7e:	82 2f       	mov	r24, r18
  80:	8a 95       	dec	r24
  82:	f1 f7       	brne	.-4      	; 0x80 <selbeep+0x14>

void selbeep() {
	uint8_t c;
	PCMSK1 = 0b00000010;
	DDRB |= 1;
	for (c=0;c<64;c++) {
  84:	9f 5f       	subi	r25, 0xFF	; 255
  86:	90 34       	cpi	r25, 0x40	; 64
  88:	b9 f7       	brne	.-18     	; 0x78 <selbeep+0xc>
		PORTB ^= 1;
		_delay_us(400);
	}
	DDRB &= ~1;
  8a:	b8 98       	cbi	0x17, 0	; 23
	PORTB |= 1;
  8c:	c0 9a       	sbi	0x18, 0	; 24
}
  8e:	08 95       	ret

00000090 <valbeep>:

void valbeep() {
	uint8_t c;
	PCMSK1 = 0b00000010;
  90:	82 e0       	ldi	r24, 0x02	; 2
  92:	80 bd       	out	0x20, r24	; 32
	DDRB |= 1;
  94:	b8 9a       	sbi	0x17, 0	; 23
  96:	90 e0       	ldi	r25, 0x00	; 0
	for (c=0;c<64;c++) {
		PORTB ^= 1;
  98:	31 e0       	ldi	r19, 0x01	; 1
  9a:	22 e4       	ldi	r18, 0x42	; 66
  9c:	88 b3       	in	r24, 0x18	; 24
  9e:	83 27       	eor	r24, r19
  a0:	88 bb       	out	0x18, r24	; 24
  a2:	82 2f       	mov	r24, r18
  a4:	8a 95       	dec	r24
  a6:	f1 f7       	brne	.-4      	; 0xa4 <valbeep+0x14>

void valbeep() {
	uint8_t c;
	PCMSK1 = 0b00000010;
	DDRB |= 1;
	for (c=0;c<64;c++) {
  a8:	9f 5f       	subi	r25, 0xFF	; 255
  aa:	90 34       	cpi	r25, 0x40	; 64
  ac:	b9 f7       	brne	.-18     	; 0x9c <valbeep+0xc>
		PORTB ^= 1;
		_delay_us(200);
	}
	DDRB &= ~1;
  ae:	b8 98       	cbi	0x17, 0	; 23
	PORTB |= 1;
  b0:	c0 9a       	sbi	0x18, 0	; 24
}
  b2:	08 95       	ret

000000b4 <__vector_8>:
	GIFR = 0;
}

ISR(PCINT1_vect, ISR_ALIASOF(PCINT0_vect));

ISR(TIM1_OVF_vect) {
  b4:	1f 92       	push	r1
  b6:	0f 92       	push	r0
  b8:	0f b6       	in	r0, 0x3f	; 63
  ba:	0f 92       	push	r0
  bc:	11 24       	eor	r1, r1
  be:	8f 93       	push	r24
	first = 1;
  c0:	81 e0       	ldi	r24, 0x01	; 1
  c2:	80 93 c9 00 	sts	0x00C9, r24
	bufidx = 0;
  c6:	10 92 ca 00 	sts	0x00CA, r1
	rbit = 0;
  ca:	10 92 c8 00 	sts	0x00C8, r1
}
  ce:	8f 91       	pop	r24
  d0:	0f 90       	pop	r0
  d2:	0f be       	out	0x3f, r0	; 63
  d4:	0f 90       	pop	r0
  d6:	1f 90       	pop	r1
  d8:	18 95       	reti

000000da <refresh_icons>:
uint16_t volatile stat_sleepy = 0;
uint16_t volatile xpos = 26, xdir;
uint8_t volatile icon_sel = 0;
uint8_t volatile buf[32];

void refresh_icons() {
  da:	ef 92       	push	r14
  dc:	0f 93       	push	r16
	uint8_t v;
	// Draw icons
	exee_read_buf(0);
  de:	80 e0       	ldi	r24, 0x00	; 0
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	92 d4       	rcall	.+2340   	; 0xa08 <exee_read_buf>
	if (icon_sel == 0) v = 0xFF; else v = 0;
  e4:	80 91 64 00 	lds	r24, 0x0064
  e8:	88 23       	and	r24, r24
  ea:	11 f0       	breq	.+4      	; 0xf0 <refresh_icons+0x16>
  ec:	00 e0       	ldi	r16, 0x00	; 0
  ee:	01 c0       	rjmp	.+2      	; 0xf2 <refresh_icons+0x18>
  f0:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(0+7,0,0,9,v,0);
  f2:	87 e0       	ldi	r24, 0x07	; 7
  f4:	60 e0       	ldi	r22, 0x00	; 0
  f6:	40 e0       	ldi	r20, 0x00	; 0
  f8:	29 e0       	ldi	r18, 0x09	; 9
  fa:	ee 24       	eor	r14, r14
  fc:	21 d3       	rcall	.+1602   	; 0x740 <drawlcd>
	if (icon_sel == 1) v = 0xFF; else v = 0;
  fe:	80 91 64 00 	lds	r24, 0x0064
 102:	81 30       	cpi	r24, 0x01	; 1
 104:	11 f0       	breq	.+4      	; 0x10a <refresh_icons+0x30>
 106:	00 e0       	ldi	r16, 0x00	; 0
 108:	01 c0       	rjmp	.+2      	; 0x10c <refresh_icons+0x32>
 10a:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(15+7,0,9,9,v,0);
 10c:	86 e1       	ldi	r24, 0x16	; 22
 10e:	60 e0       	ldi	r22, 0x00	; 0
 110:	49 e0       	ldi	r20, 0x09	; 9
 112:	29 e0       	ldi	r18, 0x09	; 9
 114:	ee 24       	eor	r14, r14
 116:	14 d3       	rcall	.+1576   	; 0x740 <drawlcd>
	if (icon_sel == 2) v = 0xFF; else v = 0;
 118:	80 91 64 00 	lds	r24, 0x0064
 11c:	82 30       	cpi	r24, 0x02	; 2
 11e:	11 f0       	breq	.+4      	; 0x124 <refresh_icons+0x4a>
 120:	00 e0       	ldi	r16, 0x00	; 0
 122:	01 c0       	rjmp	.+2      	; 0x126 <refresh_icons+0x4c>
 124:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(30+7,0,18,9,v,0);
 126:	85 e2       	ldi	r24, 0x25	; 37
 128:	60 e0       	ldi	r22, 0x00	; 0
 12a:	42 e1       	ldi	r20, 0x12	; 18
 12c:	29 e0       	ldi	r18, 0x09	; 9
 12e:	ee 24       	eor	r14, r14
 130:	07 d3       	rcall	.+1550   	; 0x740 <drawlcd>
	if (icon_sel == 3) v = 0xFF; else v = 0;
 132:	80 91 64 00 	lds	r24, 0x0064
 136:	83 30       	cpi	r24, 0x03	; 3
 138:	11 f0       	breq	.+4      	; 0x13e <refresh_icons+0x64>
 13a:	00 e0       	ldi	r16, 0x00	; 0
 13c:	01 c0       	rjmp	.+2      	; 0x140 <refresh_icons+0x66>
 13e:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(45+7,0,27,9,v,0);
 140:	84 e3       	ldi	r24, 0x34	; 52
 142:	60 e0       	ldi	r22, 0x00	; 0
 144:	4b e1       	ldi	r20, 0x1B	; 27
 146:	29 e0       	ldi	r18, 0x09	; 9
 148:	ee 24       	eor	r14, r14
 14a:	fa d2       	rcall	.+1524   	; 0x740 <drawlcd>
	if (icon_sel == 4) v = 0xFF; else v = 0;
 14c:	80 91 64 00 	lds	r24, 0x0064
 150:	84 30       	cpi	r24, 0x04	; 4
 152:	11 f0       	breq	.+4      	; 0x158 <refresh_icons+0x7e>
 154:	00 e0       	ldi	r16, 0x00	; 0
 156:	01 c0       	rjmp	.+2      	; 0x15a <refresh_icons+0x80>
 158:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(60+7,0,36,9,v,0);
 15a:	83 e4       	ldi	r24, 0x43	; 67
 15c:	60 e0       	ldi	r22, 0x00	; 0
 15e:	44 e2       	ldi	r20, 0x24	; 36
 160:	29 e0       	ldi	r18, 0x09	; 9
 162:	ee 24       	eor	r14, r14
 164:	ed d2       	rcall	.+1498   	; 0x740 <drawlcd>
	if (icon_sel == 5) v = 0xFF; else v = 0;
 166:	80 91 64 00 	lds	r24, 0x0064
 16a:	85 30       	cpi	r24, 0x05	; 5
 16c:	11 f0       	breq	.+4      	; 0x172 <__stack+0x13>
 16e:	00 e0       	ldi	r16, 0x00	; 0
 170:	01 c0       	rjmp	.+2      	; 0x174 <__stack+0x15>
 172:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(0+7,5,45,9,v,0);
 174:	87 e0       	ldi	r24, 0x07	; 7
 176:	65 e0       	ldi	r22, 0x05	; 5
 178:	4d e2       	ldi	r20, 0x2D	; 45
 17a:	29 e0       	ldi	r18, 0x09	; 9
 17c:	ee 24       	eor	r14, r14
 17e:	e0 d2       	rcall	.+1472   	; 0x740 <drawlcd>
	if (icon_sel == 6) v = 0xFF; else v = 0;
 180:	80 91 64 00 	lds	r24, 0x0064
 184:	86 30       	cpi	r24, 0x06	; 6
 186:	11 f0       	breq	.+4      	; 0x18c <__stack+0x2d>
 188:	00 e0       	ldi	r16, 0x00	; 0
 18a:	01 c0       	rjmp	.+2      	; 0x18e <__stack+0x2f>
 18c:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(15+7,5,54,9,v,0);
 18e:	86 e1       	ldi	r24, 0x16	; 22
 190:	65 e0       	ldi	r22, 0x05	; 5
 192:	46 e3       	ldi	r20, 0x36	; 54
 194:	29 e0       	ldi	r18, 0x09	; 9
 196:	ee 24       	eor	r14, r14
 198:	d3 d2       	rcall	.+1446   	; 0x740 <drawlcd>
	exee_read_buf(1);
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	34 d4       	rcall	.+2152   	; 0xa08 <exee_read_buf>
	if (icon_sel == 7) v = 0xFF; else v = 0;
 1a0:	80 91 64 00 	lds	r24, 0x0064
 1a4:	87 30       	cpi	r24, 0x07	; 7
 1a6:	11 f0       	breq	.+4      	; 0x1ac <__stack+0x4d>
 1a8:	00 e0       	ldi	r16, 0x00	; 0
 1aa:	01 c0       	rjmp	.+2      	; 0x1ae <__stack+0x4f>
 1ac:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(30+7,5,0,9,v,0);
 1ae:	85 e2       	ldi	r24, 0x25	; 37
 1b0:	65 e0       	ldi	r22, 0x05	; 5
 1b2:	40 e0       	ldi	r20, 0x00	; 0
 1b4:	29 e0       	ldi	r18, 0x09	; 9
 1b6:	ee 24       	eor	r14, r14
 1b8:	c3 d2       	rcall	.+1414   	; 0x740 <drawlcd>
	if (icon_sel == 8) v = 0xFF; else v = 0;
 1ba:	80 91 64 00 	lds	r24, 0x0064
 1be:	88 30       	cpi	r24, 0x08	; 8
 1c0:	11 f0       	breq	.+4      	; 0x1c6 <__stack+0x67>
 1c2:	00 e0       	ldi	r16, 0x00	; 0
 1c4:	01 c0       	rjmp	.+2      	; 0x1c8 <__stack+0x69>
 1c6:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(45+7,5,9,9,v,0);
 1c8:	84 e3       	ldi	r24, 0x34	; 52
 1ca:	65 e0       	ldi	r22, 0x05	; 5
 1cc:	49 e0       	ldi	r20, 0x09	; 9
 1ce:	29 e0       	ldi	r18, 0x09	; 9
 1d0:	ee 24       	eor	r14, r14
 1d2:	b6 d2       	rcall	.+1388   	; 0x740 <drawlcd>
	if (icon_sel == 9) v = 0xFF; else v = 0;
 1d4:	80 91 64 00 	lds	r24, 0x0064
 1d8:	89 30       	cpi	r24, 0x09	; 9
 1da:	11 f0       	breq	.+4      	; 0x1e0 <__stack+0x81>
 1dc:	00 e0       	ldi	r16, 0x00	; 0
 1de:	01 c0       	rjmp	.+2      	; 0x1e2 <__stack+0x83>
 1e0:	0f ef       	ldi	r16, 0xFF	; 255
	drawlcd(60+7,5,18,9,v,0);
 1e2:	83 e4       	ldi	r24, 0x43	; 67
 1e4:	65 e0       	ldi	r22, 0x05	; 5
 1e6:	42 e1       	ldi	r20, 0x12	; 18
 1e8:	29 e0       	ldi	r18, 0x09	; 9
 1ea:	ee 24       	eor	r14, r14
 1ec:	a9 d2       	rcall	.+1362   	; 0x740 <drawlcd>
}
 1ee:	0f 91       	pop	r16
 1f0:	ef 90       	pop	r14
 1f2:	08 95       	ret

000001f4 <__vector_2>:
	}
	DDRB &= ~1;
	PORTB |= 1;
}

ISR(PCINT0_vect) {
 1f4:	1f 92       	push	r1
 1f6:	0f 92       	push	r0
 1f8:	0f b6       	in	r0, 0x3f	; 63
 1fa:	0f 92       	push	r0
 1fc:	11 24       	eor	r1, r1
 1fe:	2f 93       	push	r18
 200:	3f 93       	push	r19
 202:	4f 93       	push	r20
 204:	5f 93       	push	r21
 206:	6f 93       	push	r22
 208:	7f 93       	push	r23
 20a:	8f 93       	push	r24
 20c:	9f 93       	push	r25
 20e:	af 93       	push	r26
 210:	bf 93       	push	r27
 212:	ef 93       	push	r30
 214:	ff 93       	push	r31
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 216:	82 ee       	ldi	r24, 0xE2	; 226
 218:	94 e0       	ldi	r25, 0x04	; 4
 21a:	01 97       	sbiw	r24, 0x01	; 1
 21c:	f1 f7       	brne	.-4      	; 0x21a <__vector_2+0x26>
	_delay_ms(5);
	if (!(PINA & _BV(PA1))) {
 21e:	c9 9b       	sbis	0x19, 1	; 25
		valbeep();
 220:	37 df       	rcall	.-402    	; 0x90 <valbeep>
	}
	if (!(PINB & _BV(PB0))) {
 222:	b0 99       	sbic	0x16, 0	; 22
 224:	0e c0       	rjmp	.+28     	; 0x242 <__vector_2+0x4e>
		if (icon_sel == 9)
 226:	80 91 64 00 	lds	r24, 0x0064
 22a:	89 30       	cpi	r24, 0x09	; 9
 22c:	19 f4       	brne	.+6      	; 0x234 <__vector_2+0x40>
			icon_sel = 0;
 22e:	10 92 64 00 	sts	0x0064, r1
 232:	05 c0       	rjmp	.+10     	; 0x23e <__vector_2+0x4a>
		else
			icon_sel++;
 234:	80 91 64 00 	lds	r24, 0x0064
 238:	8f 5f       	subi	r24, 0xFF	; 255
 23a:	80 93 64 00 	sts	0x0064, r24
		refresh_icons();
 23e:	4d df       	rcall	.-358    	; 0xda <refresh_icons>
		selbeep();
 240:	15 df       	rcall	.-470    	; 0x6c <selbeep>
	}
	if (!(PINB & _BV(PB1))) {
 242:	b1 9b       	sbis	0x16, 1	; 22
		valbeep();
 244:	25 df       	rcall	.-438    	; 0x90 <valbeep>
 246:	86 ea       	ldi	r24, 0xA6	; 166
 248:	9e e0       	ldi	r25, 0x0E	; 14
 24a:	01 97       	sbiw	r24, 0x01	; 1
 24c:	f1 f7       	brne	.-4      	; 0x24a <__vector_2+0x56>
	}
	_delay_ms(15);
	PCMSK1 = 0b00000011;
 24e:	83 e0       	ldi	r24, 0x03	; 3
 250:	80 bd       	out	0x20, r24	; 32
	GIFR = 0;
 252:	1a be       	out	0x3a, r1	; 58
}
 254:	ff 91       	pop	r31
 256:	ef 91       	pop	r30
 258:	bf 91       	pop	r27
 25a:	af 91       	pop	r26
 25c:	9f 91       	pop	r25
 25e:	8f 91       	pop	r24
 260:	7f 91       	pop	r23
 262:	6f 91       	pop	r22
 264:	5f 91       	pop	r21
 266:	4f 91       	pop	r20
 268:	3f 91       	pop	r19
 26a:	2f 91       	pop	r18
 26c:	0f 90       	pop	r0
 26e:	0f be       	out	0x3f, r0	; 63
 270:	0f 90       	pop	r0
 272:	1f 90       	pop	r1
 274:	18 95       	reti

00000276 <main>:
	} else {
		first = 0;
	}
}

int main(void) {
 276:	9f 92       	push	r9
 278:	af 92       	push	r10
 27a:	bf 92       	push	r11
 27c:	cf 92       	push	r12
 27e:	df 92       	push	r13
 280:	ef 92       	push	r14
 282:	ff 92       	push	r15
 284:	0f 93       	push	r16
 286:	1f 93       	push	r17
 288:	cf 93       	push	r28
 28a:	df 93       	push	r29
	uint8_t c, b, bc, anim = 0;

	WDTCSR |= (1<<WDCE) | (1<<WDE);
 28c:	81 b5       	in	r24, 0x21	; 33
 28e:	88 61       	ori	r24, 0x18	; 24
 290:	81 bd       	out	0x21, r24	; 33
	WDTCSR = 0x00;
 292:	11 bc       	out	0x21, r1	; 33

	DDRA = 0b01111100;
 294:	8c e7       	ldi	r24, 0x7C	; 124
 296:	8a bb       	out	0x1a, r24	; 26
	DDRB = 0b00000000;
 298:	17 ba       	out	0x17, r1	; 23
	PORTA = 2;
 29a:	92 e0       	ldi	r25, 0x02	; 2
 29c:	9b bb       	out	0x1b, r25	; 27
	PORTB = 3;
 29e:	23 e0       	ldi	r18, 0x03	; 3
 2a0:	28 bb       	out	0x18, r18	; 24

	MCUCR = 0b00000010;
 2a2:	95 bf       	out	0x35, r25	; 53
	GIMSK = 0b01110000;
 2a4:	80 e7       	ldi	r24, 0x70	; 112
 2a6:	8b bf       	out	0x3b, r24	; 59
	PCMSK1 =0b00000011;
 2a8:	20 bd       	out	0x20, r18	; 32
	PCMSK0 =0b00000010;
 2aa:	92 bb       	out	0x12, r25	; 18

	TCCR1A = 0b00000000;
 2ac:	1f bc       	out	0x2f, r1	; 47
	TCCR1B = 0b00000001;
 2ae:	11 e0       	ldi	r17, 0x01	; 1
 2b0:	1e bd       	out	0x2e, r17	; 46
	TIMSK1 = 0b00000001;
 2b2:	1c b9       	out	0x0c, r17	; 12

	//Reset LCD
	PORTA = 0b11000110;
 2b4:	96 ec       	ldi	r25, 0xC6	; 198
 2b6:	9b bb       	out	0x1b, r25	; 27
 2b8:	24 ed       	ldi	r18, 0xD4	; 212
 2ba:	30 e3       	ldi	r19, 0x30	; 48
 2bc:	f9 01       	movw	r30, r18
 2be:	31 97       	sbiw	r30, 0x01	; 1
 2c0:	f1 f7       	brne	.-4      	; 0x2be <main+0x48>
	_delay_ms(50);
	PORTA = 0b10000110;
 2c2:	86 e8       	ldi	r24, 0x86	; 134
 2c4:	8b bb       	out	0x1b, r24	; 27
 2c6:	e4 ec       	ldi	r30, 0xC4	; 196
 2c8:	f9 e0       	ldi	r31, 0x09	; 9
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	f1 f7       	brne	.-4      	; 0x2ca <main+0x54>
	_delay_ms(10);
	PORTA = 0b11000110;
 2ce:	9b bb       	out	0x1b, r25	; 27
 2d0:	c9 01       	movw	r24, r18
 2d2:	01 97       	sbiw	r24, 0x01	; 1
 2d4:	f1 f7       	brne	.-4      	; 0x2d2 <main+0x5c>
	_delay_ms(50);

	txlcd(0x21);
 2d6:	81 e2       	ldi	r24, 0x21	; 33
 2d8:	f1 d1       	rcall	.+994    	; 0x6bc <txlcd>
	txlcd(0xAE);
 2da:	8e ea       	ldi	r24, 0xAE	; 174
 2dc:	ef d1       	rcall	.+990    	; 0x6bc <txlcd>
	txlcd(0x13);
 2de:	83 e1       	ldi	r24, 0x13	; 19
 2e0:	ed d1       	rcall	.+986    	; 0x6bc <txlcd>
	txlcd(0x20);
 2e2:	80 e2       	ldi	r24, 0x20	; 32
 2e4:	eb d1       	rcall	.+982    	; 0x6bc <txlcd>
	txlcd(0x0C);
 2e6:	8c e0       	ldi	r24, 0x0C	; 12
 2e8:	e9 d1       	rcall	.+978    	; 0x6bc <txlcd>

	clrlcd();
 2ea:	13 d2       	rcall	.+1062   	; 0x712 <clrlcd>

	ADMUX = 0b10000000;
 2ec:	80 e8       	ldi	r24, 0x80	; 128
 2ee:	87 b9       	out	0x07, r24	; 7
	ADCSRA = 0b10000100;
 2f0:	84 e8       	ldi	r24, 0x84	; 132
 2f2:	86 b9       	out	0x06, r24	; 6
	ADCSRB = 0b00010000;
 2f4:	80 e1       	ldi	r24, 0x10	; 16
 2f6:	83 b9       	out	0x03, r24	; 3
	DIDR0 = 0b00000001;
 2f8:	11 b9       	out	0x01, r17	; 1

	refresh_icons();
 2fa:	ef de       	rcall	.-546    	; 0xda <refresh_icons>

	//lcdxy(20,3);
	//lcdtxt("0123456789");

	drawfur(P_STANDING,0);
 2fc:	80 e1       	ldi	r24, 0x10	; 16
 2fe:	60 e0       	ldi	r22, 0x00	; 0
 300:	50 d2       	rcall	.+1184   	; 0x7a2 <drawfur>

	sei();
 302:	78 94       	sei
 304:	ff 24       	eor	r15, r15
 306:	c0 e2       	ldi	r28, 0x20	; 32
 308:	de e4       	ldi	r29, 0x4E	; 78
			valbeep();
			_delay_ms(80);
		}
		if ((state == AWAKE) && (b < 80)) {
			drawfur(P_FOURS,xdir);
			fatimer = 10;
 30a:	6a e0       	ldi	r22, 0x0A	; 10
 30c:	96 2e       	mov	r9, r22
			if (fatimer)
				fatimer--;
			else {
				drawfur(P_SLEEPING,xdir);
				selbeep();
				state = SLEEP;
 30e:	cc 24       	eor	r12, r12
 310:	c3 94       	inc	r12
 312:	50 e5       	ldi	r21, 0x50	; 80
 314:	a5 2e       	mov	r10, r21
 316:	53 ec       	ldi	r21, 0xC3	; 195
 318:	b5 2e       	mov	r11, r21
	drawfur(P_STANDING,0);

	sei();

	for(;;) {
		b = get_adc();
 31a:	9f de       	rcall	.-706    	; 0x5a <get_adc>
 31c:	d8 2e       	mov	r13, r24
		//Fall asleep: return to center of screen (xpos=26)
		//Then all4s
		//Then sleeping
		//Don't fuck around with Zz icon's position...

		if (state == SLEEP) {
 31e:	80 91 a7 00 	lds	r24, 0x00A7
 322:	81 30       	cpi	r24, 0x01	; 1
 324:	09 f0       	breq	.+2      	; 0x328 <main+0xb2>
 326:	41 c0       	rjmp	.+130    	; 0x3aa <main+0x134>
			if (anim & 1) {
 328:	0f 2d       	mov	r16, r15
 32a:	10 e0       	ldi	r17, 0x00	; 0
 32c:	f0 fe       	sbrs	r15, 0
 32e:	2e c0       	rjmp	.+92     	; 0x38c <main+0x116>
				exee_read_buf(1);
 330:	81 e0       	ldi	r24, 0x01	; 1
 332:	90 e0       	ldi	r25, 0x00	; 0
 334:	69 d3       	rcall	.+1746   	; 0xa08 <exee_read_buf>
				if (xpos >= 10)
 336:	80 91 60 00 	lds	r24, 0x0060
 33a:	90 91 61 00 	lds	r25, 0x0061
 33e:	a8 01       	movw	r20, r16
 340:	42 70       	andi	r20, 0x02	; 2
 342:	50 70       	andi	r21, 0x00	; 0
 344:	0a 97       	sbiw	r24, 0x0a	; 10
 346:	78 f0       	brcs	.+30     	; 0x366 <main+0xf0>
					drawlcd(xpos-10,2,18+((anim&2)>>1)*9,9,0,0);
 348:	20 91 60 00 	lds	r18, 0x0060
 34c:	30 91 61 00 	lds	r19, 0x0061
 350:	ca 01       	movw	r24, r20
 352:	96 95       	lsr	r25
 354:	87 95       	ror	r24
 356:	69 e0       	ldi	r22, 0x09	; 9
 358:	70 e0       	ldi	r23, 0x00	; 0
 35a:	7f d3       	rcall	.+1790   	; 0xa5a <__mulhi3>
 35c:	48 2f       	mov	r20, r24
 35e:	4e 5e       	subi	r20, 0xEE	; 238
 360:	82 2f       	mov	r24, r18
 362:	8a 50       	subi	r24, 0x0A	; 10
 364:	0e c0       	rjmp	.+28     	; 0x382 <main+0x10c>
				else
					drawlcd(xpos+32+1,2,18+((anim&2)>>1)*9,9,0,0);
 366:	20 91 60 00 	lds	r18, 0x0060
 36a:	30 91 61 00 	lds	r19, 0x0061
 36e:	ca 01       	movw	r24, r20
 370:	96 95       	lsr	r25
 372:	87 95       	ror	r24
 374:	69 e0       	ldi	r22, 0x09	; 9
 376:	70 e0       	ldi	r23, 0x00	; 0
 378:	70 d3       	rcall	.+1760   	; 0xa5a <__mulhi3>
 37a:	48 2f       	mov	r20, r24
 37c:	4e 5e       	subi	r20, 0xEE	; 238
 37e:	82 2f       	mov	r24, r18
 380:	8f 5d       	subi	r24, 0xDF	; 223
 382:	62 e0       	ldi	r22, 0x02	; 2
 384:	29 e0       	ldi	r18, 0x09	; 9
 386:	00 e0       	ldi	r16, 0x00	; 0
 388:	ee 24       	eor	r14, r14
 38a:	da d1       	rcall	.+948    	; 0x740 <drawlcd>
			}
			if (stat_sleepy) stat_sleepy--;
 38c:	80 91 62 00 	lds	r24, 0x0062
 390:	90 91 63 00 	lds	r25, 0x0063
 394:	89 2b       	or	r24, r25
 396:	49 f0       	breq	.+18     	; 0x3aa <main+0x134>
 398:	80 91 62 00 	lds	r24, 0x0062
 39c:	90 91 63 00 	lds	r25, 0x0063
 3a0:	01 97       	sbiw	r24, 0x01	; 1
 3a2:	90 93 63 00 	sts	0x0063, r25
 3a6:	80 93 62 00 	sts	0x0062, r24
		}

		if (state == AWAKE) {
 3aa:	80 91 a7 00 	lds	r24, 0x00A7
 3ae:	88 23       	and	r24, r24
 3b0:	09 f0       	breq	.+2      	; 0x3b4 <main+0x13e>
 3b2:	4d c0       	rjmp	.+154    	; 0x44e <main+0x1d8>
			if ((anim & 3) == 0) drawfur(P_STANDING,xdir);
 3b4:	8f 2d       	mov	r24, r15
 3b6:	90 e0       	ldi	r25, 0x00	; 0
 3b8:	83 70       	andi	r24, 0x03	; 3
 3ba:	90 70       	andi	r25, 0x00	; 0
 3bc:	00 97       	sbiw	r24, 0x00	; 0
 3be:	61 f0       	breq	.+24     	; 0x3d8 <main+0x162>
			if ((anim & 3) == 1) drawfur(P_WC,xdir);
 3c0:	81 30       	cpi	r24, 0x01	; 1
 3c2:	91 05       	cpc	r25, r1
 3c4:	31 f4       	brne	.+12     	; 0x3d2 <main+0x15c>
 3c6:	60 91 cb 00 	lds	r22, 0x00CB
 3ca:	70 91 cc 00 	lds	r23, 0x00CC
 3ce:	86 e1       	ldi	r24, 0x16	; 22
 3d0:	10 c0       	rjmp	.+32     	; 0x3f2 <main+0x17c>
			if ((anim & 3) == 2) drawfur(P_STANDING,xdir);
 3d2:	82 30       	cpi	r24, 0x02	; 2
 3d4:	91 05       	cpc	r25, r1
 3d6:	31 f4       	brne	.+12     	; 0x3e4 <main+0x16e>
 3d8:	60 91 cb 00 	lds	r22, 0x00CB
 3dc:	70 91 cc 00 	lds	r23, 0x00CC
 3e0:	80 e1       	ldi	r24, 0x10	; 16
 3e2:	07 c0       	rjmp	.+14     	; 0x3f2 <main+0x17c>
			if ((anim & 3) == 3) drawfur(P_WC+2,xdir);
 3e4:	03 97       	sbiw	r24, 0x03	; 3
 3e6:	31 f4       	brne	.+12     	; 0x3f4 <main+0x17e>
 3e8:	60 91 cb 00 	lds	r22, 0x00CB
 3ec:	70 91 cc 00 	lds	r23, 0x00CC
 3f0:	88 e1       	ldi	r24, 0x18	; 24
 3f2:	d7 d1       	rcall	.+942    	; 0x7a2 <drawfur>
			if (!xdir) {
 3f4:	80 91 cb 00 	lds	r24, 0x00CB
 3f8:	90 91 cc 00 	lds	r25, 0x00CC
 3fc:	89 2b       	or	r24, r25
 3fe:	99 f4       	brne	.+38     	; 0x426 <main+0x1b0>
				if (xpos) {
 400:	80 91 60 00 	lds	r24, 0x0060
 404:	90 91 61 00 	lds	r25, 0x0061
 408:	89 2b       	or	r24, r25
 40a:	31 f0       	breq	.+12     	; 0x418 <main+0x1a2>
					xpos-=2;
 40c:	80 91 60 00 	lds	r24, 0x0060
 410:	90 91 61 00 	lds	r25, 0x0061
 414:	02 97       	sbiw	r24, 0x02	; 2
 416:	12 c0       	rjmp	.+36     	; 0x43c <main+0x1c6>
				} else {
					xdir = 1;
 418:	81 e0       	ldi	r24, 0x01	; 1
 41a:	90 e0       	ldi	r25, 0x00	; 0
 41c:	90 93 cc 00 	sts	0x00CC, r25
 420:	80 93 cb 00 	sts	0x00CB, r24
 424:	14 c0       	rjmp	.+40     	; 0x44e <main+0x1d8>
				}
			} else {
				if (xpos < 51) {
 426:	80 91 60 00 	lds	r24, 0x0060
 42a:	90 91 61 00 	lds	r25, 0x0061
 42e:	c3 97       	sbiw	r24, 0x33	; 51
 430:	50 f4       	brcc	.+20     	; 0x446 <main+0x1d0>
					xpos+=2;
 432:	80 91 60 00 	lds	r24, 0x0060
 436:	90 91 61 00 	lds	r25, 0x0061
 43a:	02 96       	adiw	r24, 0x02	; 2
 43c:	90 93 61 00 	sts	0x0061, r25
 440:	80 93 60 00 	sts	0x0060, r24
 444:	04 c0       	rjmp	.+8      	; 0x44e <main+0x1d8>
				} else {
					xdir = 0;
 446:	10 92 cc 00 	sts	0x00CC, r1
 44a:	10 92 cb 00 	sts	0x00CB, r1
				}
			}
		}

		if (((state == SLEEP) || (state == FA)) && (b > 100)) {
 44e:	80 91 a7 00 	lds	r24, 0x00A7
 452:	81 30       	cpi	r24, 0x01	; 1
 454:	21 f0       	breq	.+8      	; 0x45e <main+0x1e8>
 456:	80 91 a7 00 	lds	r24, 0x00A7
 45a:	82 30       	cpi	r24, 0x02	; 2
 45c:	41 f5       	brne	.+80     	; 0x4ae <main+0x238>
 45e:	84 e6       	ldi	r24, 0x64	; 100
 460:	8d 15       	cp	r24, r13
 462:	28 f5       	brcc	.+74     	; 0x4ae <main+0x238>
			lcdxy(22,2);
 464:	86 e1       	ldi	r24, 0x16	; 22
 466:	62 e0       	ldi	r22, 0x02	; 2
 468:	60 d1       	rcall	.+704    	; 0x72a <lcdxy>
			txlcd(0);
 46a:	80 e0       	ldi	r24, 0x00	; 0
 46c:	27 d1       	rcall	.+590    	; 0x6bc <txlcd>
			txlcd(0);
 46e:	80 e0       	ldi	r24, 0x00	; 0
 470:	25 d1       	rcall	.+586    	; 0x6bc <txlcd>
			txlcd(0);
 472:	80 e0       	ldi	r24, 0x00	; 0
 474:	23 d1       	rcall	.+582    	; 0x6bc <txlcd>
			txlcd(0);
 476:	80 e0       	ldi	r24, 0x00	; 0
 478:	21 d1       	rcall	.+578    	; 0x6bc <txlcd>
			txlcd(0);
 47a:	80 e0       	ldi	r24, 0x00	; 0
 47c:	1f d1       	rcall	.+574    	; 0x6bc <txlcd>
			txlcd(0);
 47e:	80 e0       	ldi	r24, 0x00	; 0
 480:	1d d1       	rcall	.+570    	; 0x6bc <txlcd>
			txlcd(0);
 482:	80 e0       	ldi	r24, 0x00	; 0
 484:	1b d1       	rcall	.+566    	; 0x6bc <txlcd>
			txlcd(0);
 486:	80 e0       	ldi	r24, 0x00	; 0
 488:	19 d1       	rcall	.+562    	; 0x6bc <txlcd>
			txlcd(0);
 48a:	80 e0       	ldi	r24, 0x00	; 0
 48c:	17 d1       	rcall	.+558    	; 0x6bc <txlcd>
			drawfur(P_STANDING,xdir);
 48e:	60 91 cb 00 	lds	r22, 0x00CB
 492:	70 91 cc 00 	lds	r23, 0x00CC
 496:	80 e1       	ldi	r24, 0x10	; 16
 498:	84 d1       	rcall	.+776    	; 0x7a2 <drawfur>
			state = AWAKE;
 49a:	10 92 a7 00 	sts	0x00A7, r1
			valbeep();
 49e:	f8 dd       	rcall	.-1040   	; 0x90 <valbeep>
 4a0:	ce 01       	movw	r24, r28
 4a2:	01 97       	sbiw	r24, 0x01	; 1
 4a4:	f1 f7       	brne	.-4      	; 0x4a2 <main+0x22c>
			_delay_ms(80);
			valbeep();
 4a6:	f4 dd       	rcall	.-1048   	; 0x90 <valbeep>
 4a8:	ce 01       	movw	r24, r28
 4aa:	01 97       	sbiw	r24, 0x01	; 1
 4ac:	f1 f7       	brne	.-4      	; 0x4aa <main+0x234>
			_delay_ms(80);
		}
		if ((state == AWAKE) && (b < 80)) {
 4ae:	80 91 a7 00 	lds	r24, 0x00A7
 4b2:	88 23       	and	r24, r24
 4b4:	79 f4       	brne	.+30     	; 0x4d4 <main+0x25e>
 4b6:	8f e4       	ldi	r24, 0x4F	; 79
 4b8:	8d 15       	cp	r24, r13
 4ba:	60 f0       	brcs	.+24     	; 0x4d4 <main+0x25e>
			drawfur(P_FOURS,xdir);
 4bc:	60 91 cb 00 	lds	r22, 0x00CB
 4c0:	70 91 cc 00 	lds	r23, 0x00CC
 4c4:	82 e1       	ldi	r24, 0x12	; 18
 4c6:	6d d1       	rcall	.+730    	; 0x7a2 <drawfur>
			fatimer = 10;
 4c8:	90 92 a5 00 	sts	0x00A5, r9
			state = FA;
 4cc:	82 e0       	ldi	r24, 0x02	; 2
 4ce:	80 93 a7 00 	sts	0x00A7, r24
			valbeep();
 4d2:	de dd       	rcall	.-1092   	; 0x90 <valbeep>
		}
		if (state == FA) {
 4d4:	80 91 a7 00 	lds	r24, 0x00A7
 4d8:	82 30       	cpi	r24, 0x02	; 2
 4da:	99 f4       	brne	.+38     	; 0x502 <main+0x28c>
			if (fatimer)
 4dc:	80 91 a5 00 	lds	r24, 0x00A5
 4e0:	88 23       	and	r24, r24
 4e2:	31 f0       	breq	.+12     	; 0x4f0 <main+0x27a>
				fatimer--;
 4e4:	80 91 a5 00 	lds	r24, 0x00A5
 4e8:	81 50       	subi	r24, 0x01	; 1
 4ea:	80 93 a5 00 	sts	0x00A5, r24
 4ee:	09 c0       	rjmp	.+18     	; 0x502 <main+0x28c>
			else {
				drawfur(P_SLEEPING,xdir);
 4f0:	60 91 cb 00 	lds	r22, 0x00CB
 4f4:	70 91 cc 00 	lds	r23, 0x00CC
 4f8:	84 e1       	ldi	r24, 0x14	; 20
 4fa:	53 d1       	rcall	.+678    	; 0x7a2 <drawfur>
				selbeep();
 4fc:	b7 dd       	rcall	.-1170   	; 0x6c <selbeep>
				state = SLEEP;
 4fe:	c0 92 a7 00 	sts	0x00A7, r12
			}
		}

		anim++;
 502:	f3 94       	inc	r15
 504:	c5 01       	movw	r24, r10
 506:	01 97       	sbiw	r24, 0x01	; 1
 508:	f1 f7       	brne	.-4      	; 0x506 <main+0x290>
 50a:	07 cf       	rjmp	.-498    	; 0x31a <main+0xa4>

0000050c <__vector_1>:
	first = 1;
	bufidx = 0;
	rbit = 0;
}

ISR(INT0_vect) {
 50c:	1f 92       	push	r1
 50e:	0f 92       	push	r0
 510:	0f b6       	in	r0, 0x3f	; 63
 512:	0f 92       	push	r0
 514:	11 24       	eor	r1, r1
 516:	1f 93       	push	r17
 518:	2f 93       	push	r18
 51a:	3f 93       	push	r19
 51c:	4f 93       	push	r20
 51e:	5f 93       	push	r21
 520:	6f 93       	push	r22
 522:	7f 93       	push	r23
 524:	8f 93       	push	r24
 526:	9f 93       	push	r25
 528:	af 93       	push	r26
 52a:	bf 93       	push	r27
 52c:	ef 93       	push	r30
 52e:	ff 93       	push	r31
	uint16_t v;
	uint8_t c,cs;

	v = TCNT1;
 530:	2c b5       	in	r18, 0x2c	; 44
 532:	3d b5       	in	r19, 0x2d	; 45
	TCNT1 = 0;
 534:	1d bc       	out	0x2d, r1	; 45
 536:	1c bc       	out	0x2c, r1	; 44

	if (!first) {
 538:	80 91 c9 00 	lds	r24, 0x00C9
 53c:	88 23       	and	r24, r24
 53e:	09 f0       	breq	.+2      	; 0x542 <__vector_1+0x36>
 540:	a9 c0       	rjmp	.+338    	; 0x694 <__vector_1+0x188>
		if (v >= 4000) {
 542:	4f e0       	ldi	r20, 0x0F	; 15
 544:	20 3a       	cpi	r18, 0xA0	; 160
 546:	34 07       	cpc	r19, r20
 548:	08 f4       	brcc	.+2      	; 0x54c <__vector_1+0x40>
 54a:	5a c0       	rjmp	.+180    	; 0x600 <__vector_1+0xf4>
			if (v < 7000) {
 54c:	28 55       	subi	r18, 0x58	; 88
 54e:	3b 41       	sbci	r19, 0x1B	; 27
 550:	08 f0       	brcs	.+2      	; 0x554 <__vector_1+0x48>
 552:	50 c0       	rjmp	.+160    	; 0x5f4 <__vector_1+0xe8>
				if (buf[0] == 0xB1) {
 554:	80 91 a8 00 	lds	r24, 0x00A8
 558:	81 3b       	cpi	r24, 0xB1	; 177
 55a:	09 f0       	breq	.+2      	; 0x55e <__vector_1+0x52>
 55c:	48 c0       	rjmp	.+144    	; 0x5ee <__vector_1+0xe2>
					buf[0] = 0;
 55e:	10 92 a8 00 	sts	0x00A8, r1
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	2a ea       	ldi	r18, 0xAA	; 170
 566:	05 c0       	rjmp	.+10     	; 0x572 <__vector_1+0x66>
					cs = 0xAA;
					for (c=0;c<buf[2];c++) {
						cs += buf[3+c];
 568:	e5 55       	subi	r30, 0x55	; 85
 56a:	ff 4f       	sbci	r31, 0xFF	; 255
 56c:	80 81       	ld	r24, Z
 56e:	28 0f       	add	r18, r24
		if (v >= 4000) {
			if (v < 7000) {
				if (buf[0] == 0xB1) {
					buf[0] = 0;
					cs = 0xAA;
					for (c=0;c<buf[2];c++) {
 570:	9f 5f       	subi	r25, 0xFF	; 255
 572:	80 91 aa 00 	lds	r24, 0x00AA
 576:	e9 2f       	mov	r30, r25
 578:	f0 e0       	ldi	r31, 0x00	; 0
 57a:	98 17       	cp	r25, r24
 57c:	a8 f3       	brcs	.-22     	; 0x568 <__vector_1+0x5c>
						cs += buf[3+c];
					}
					if (cs == buf[3+c]) {
 57e:	e5 55       	subi	r30, 0x55	; 85
 580:	ff 4f       	sbci	r31, 0xFF	; 255
 582:	80 81       	ld	r24, Z
 584:	28 17       	cp	r18, r24
 586:	99 f5       	brne	.+102    	; 0x5ee <__vector_1+0xe2>
						//Beep
						PCMSK1 =0b00000010;
 588:	82 e0       	ldi	r24, 0x02	; 2
 58a:	80 bd       	out	0x20, r24	; 32
						DDRB |= 1;
 58c:	b8 9a       	sbi	0x17, 0	; 23
 58e:	90 e0       	ldi	r25, 0x00	; 0
						for (c=0;c<32;c++) {
							PORTB ^= 1;
 590:	31 e0       	ldi	r19, 0x01	; 1
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 592:	22 e4       	ldi	r18, 0x42	; 66
 594:	88 b3       	in	r24, 0x18	; 24
 596:	83 27       	eor	r24, r19
 598:	88 bb       	out	0x18, r24	; 24
 59a:	82 2f       	mov	r24, r18
 59c:	8a 95       	dec	r24
 59e:	f1 f7       	brne	.-4      	; 0x59c <__vector_1+0x90>
					}
					if (cs == buf[3+c]) {
						//Beep
						PCMSK1 =0b00000010;
						DDRB |= 1;
						for (c=0;c<32;c++) {
 5a0:	9f 5f       	subi	r25, 0xFF	; 255
 5a2:	90 32       	cpi	r25, 0x20	; 32
 5a4:	b9 f7       	brne	.-18     	; 0x594 <__vector_1+0x88>
							PORTB ^= 1;
							_delay_us(200);
						}
						DDRB &= ~1;
 5a6:	b8 98       	cbi	0x17, 0	; 23
						PORTB |= 1;
 5a8:	c0 9a       	sbi	0x18, 0	; 24
						PCMSK1 =0b00000011;
 5aa:	83 e0       	ldi	r24, 0x03	; 3
 5ac:	80 bd       	out	0x20, r24	; 32

						if (buf[1] == 0) {
 5ae:	80 91 a9 00 	lds	r24, 0x00A9
 5b2:	88 23       	and	r24, r24
 5b4:	d9 f4       	brne	.+54     	; 0x5ec <__vector_1+0xe0>
							/*PORTA = 0b11000000;
							txlcd(0x40);
							txlcd(0x80);
							PORTA = 0b11001000;*/

							i2c_start();
 5b6:	6b d1       	rcall	.+726    	; 0x88e <i2c_start>
							i2c_write(0xA0);
 5b8:	80 ea       	ldi	r24, 0xA0	; 160
 5ba:	8e d1       	rcall	.+796    	; 0x8d8 <i2c_write>
							i2c_write(buf[3]);
 5bc:	80 91 ab 00 	lds	r24, 0x00AB
 5c0:	8b d1       	rcall	.+790    	; 0x8d8 <i2c_write>
							i2c_write(buf[3+1]);
 5c2:	80 91 ac 00 	lds	r24, 0x00AC
 5c6:	88 d1       	rcall	.+784    	; 0x8d8 <i2c_write>
 5c8:	10 e0       	ldi	r17, 0x00	; 0
 5ca:	05 c0       	rjmp	.+10     	; 0x5d6 <__vector_1+0xca>
							for (c=0;c<buf[2]-2;c++) {
								i2c_write(buf[c+3+2]);
 5cc:	e3 55       	subi	r30, 0x53	; 83
 5ce:	ff 4f       	sbci	r31, 0xFF	; 255
 5d0:	80 81       	ld	r24, Z
 5d2:	82 d1       	rcall	.+772    	; 0x8d8 <i2c_write>

							i2c_start();
							i2c_write(0xA0);
							i2c_write(buf[3]);
							i2c_write(buf[3+1]);
							for (c=0;c<buf[2]-2;c++) {
 5d4:	1f 5f       	subi	r17, 0xFF	; 255
 5d6:	e1 2f       	mov	r30, r17
 5d8:	f0 e0       	ldi	r31, 0x00	; 0
 5da:	80 91 aa 00 	lds	r24, 0x00AA
 5de:	90 e0       	ldi	r25, 0x00	; 0
 5e0:	02 97       	sbiw	r24, 0x02	; 2
 5e2:	e8 17       	cp	r30, r24
 5e4:	f9 07       	cpc	r31, r25
 5e6:	94 f3       	brlt	.-28     	; 0x5cc <__vector_1+0xc0>
								i2c_write(buf[c+3+2]);
								//txlcd(buf[c+3]);
							}
							i2c_stop();
 5e8:	62 d1       	rcall	.+708    	; 0x8ae <i2c_stop>
 5ea:	01 c0       	rjmp	.+2      	; 0x5ee <__vector_1+0xe2>
						} else {
							clrlcd();
 5ec:	92 d0       	rcall	.+292    	; 0x712 <clrlcd>
							PORTA = 0b11001000;
							lcdtxt("SERGAL");*/
						}
					}
				}
				bufidx = 0;
 5ee:	10 92 ca 00 	sts	0x00CA, r1
 5f2:	52 c0       	rjmp	.+164    	; 0x698 <__vector_1+0x18c>
			} else {
				first = 1;
 5f4:	81 e0       	ldi	r24, 0x01	; 1
 5f6:	80 93 c9 00 	sts	0x00C9, r24
				bufidx = 0;
 5fa:	10 92 ca 00 	sts	0x00CA, r1
 5fe:	41 c0       	rjmp	.+130    	; 0x682 <__vector_1+0x176>
				rbit = 0;
			}
		} else { 
			rs = rs >> 2;
 600:	80 91 a6 00 	lds	r24, 0x00A6
 604:	86 95       	lsr	r24
 606:	86 95       	lsr	r24
 608:	80 93 a6 00 	sts	0x00A6, r24
			if ((v >= 800) && (v < 1600)) rs |= 0x00;
 60c:	c9 01       	movw	r24, r18
 60e:	80 52       	subi	r24, 0x20	; 32
 610:	93 40       	sbci	r25, 0x03	; 3
 612:	80 52       	subi	r24, 0x20	; 32
 614:	93 40       	sbci	r25, 0x03	; 3
 616:	20 f4       	brcc	.+8      	; 0x620 <__vector_1+0x114>
 618:	80 91 a6 00 	lds	r24, 0x00A6
 61c:	80 93 a6 00 	sts	0x00A6, r24
			if ((v >= 1600) && (v < 2400)) rs |= 0x40;
 620:	c9 01       	movw	r24, r18
 622:	80 54       	subi	r24, 0x40	; 64
 624:	96 40       	sbci	r25, 0x06	; 6
 626:	80 52       	subi	r24, 0x20	; 32
 628:	93 40       	sbci	r25, 0x03	; 3
 62a:	28 f4       	brcc	.+10     	; 0x636 <__vector_1+0x12a>
 62c:	80 91 a6 00 	lds	r24, 0x00A6
 630:	80 64       	ori	r24, 0x40	; 64
 632:	80 93 a6 00 	sts	0x00A6, r24
			if ((v >= 2400) && (v < 3200)) rs |= 0x80;
 636:	c9 01       	movw	r24, r18
 638:	80 56       	subi	r24, 0x60	; 96
 63a:	99 40       	sbci	r25, 0x09	; 9
 63c:	80 52       	subi	r24, 0x20	; 32
 63e:	93 40       	sbci	r25, 0x03	; 3
 640:	28 f4       	brcc	.+10     	; 0x64c <__vector_1+0x140>
 642:	80 91 a6 00 	lds	r24, 0x00A6
 646:	80 68       	ori	r24, 0x80	; 128
 648:	80 93 a6 00 	sts	0x00A6, r24
			if ((v >= 3200) && (v < 4000)) rs |= 0xC0;
 64c:	20 58       	subi	r18, 0x80	; 128
 64e:	3c 40       	sbci	r19, 0x0C	; 12
 650:	20 52       	subi	r18, 0x20	; 32
 652:	33 40       	sbci	r19, 0x03	; 3
 654:	28 f4       	brcc	.+10     	; 0x660 <__vector_1+0x154>
 656:	80 91 a6 00 	lds	r24, 0x00A6
 65a:	80 6c       	ori	r24, 0xC0	; 192
 65c:	80 93 a6 00 	sts	0x00A6, r24

			if (rbit == 3) {
 660:	80 91 c8 00 	lds	r24, 0x00C8
 664:	83 30       	cpi	r24, 0x03	; 3
 666:	81 f4       	brne	.+32     	; 0x688 <__vector_1+0x17c>
				buf[bufidx] = rs;
 668:	e0 91 ca 00 	lds	r30, 0x00CA
 66c:	f0 e0       	ldi	r31, 0x00	; 0
 66e:	80 91 a6 00 	lds	r24, 0x00A6
 672:	e8 55       	subi	r30, 0x58	; 88
 674:	ff 4f       	sbci	r31, 0xFF	; 255
 676:	80 83       	st	Z, r24
				bufidx++;
 678:	80 91 ca 00 	lds	r24, 0x00CA
 67c:	8f 5f       	subi	r24, 0xFF	; 255
 67e:	80 93 ca 00 	sts	0x00CA, r24
				rbit = 0;
 682:	10 92 c8 00 	sts	0x00C8, r1
 686:	08 c0       	rjmp	.+16     	; 0x698 <__vector_1+0x18c>
			} else {
				rbit++;
 688:	80 91 c8 00 	lds	r24, 0x00C8
 68c:	8f 5f       	subi	r24, 0xFF	; 255
 68e:	80 93 c8 00 	sts	0x00C8, r24
 692:	02 c0       	rjmp	.+4      	; 0x698 <__vector_1+0x18c>
			}
		}
	} else {
		first = 0;
 694:	10 92 c9 00 	sts	0x00C9, r1
	}
}
 698:	ff 91       	pop	r31
 69a:	ef 91       	pop	r30
 69c:	bf 91       	pop	r27
 69e:	af 91       	pop	r26
 6a0:	9f 91       	pop	r25
 6a2:	8f 91       	pop	r24
 6a4:	7f 91       	pop	r23
 6a6:	6f 91       	pop	r22
 6a8:	5f 91       	pop	r21
 6aa:	4f 91       	pop	r20
 6ac:	3f 91       	pop	r19
 6ae:	2f 91       	pop	r18
 6b0:	1f 91       	pop	r17
 6b2:	0f 90       	pop	r0
 6b4:	0f be       	out	0x3f, r0	; 63
 6b6:	0f 90       	pop	r0
 6b8:	1f 90       	pop	r1
 6ba:	18 95       	reti

000006bc <txlcd>:
extern uint8_t xpos;

void txlcd(uint8_t b) {
	uint8_t c;

	PORTA &= ~_BV(PA2);
 6bc:	da 98       	cbi	0x1b, 2	; 27
 6be:	21 e0       	ldi	r18, 0x01	; 1
 6c0:	2a 95       	dec	r18
 6c2:	f1 f7       	brne	.-4      	; 0x6c0 <txlcd+0x4>
 6c4:	20 e0       	ldi	r18, 0x00	; 0
 6c6:	30 e0       	ldi	r19, 0x00	; 0
	_delay_us(2);
	for (c=0;c<8;c++) {
		if ((b<<c)&0x80)
 6c8:	48 2f       	mov	r20, r24
 6ca:	50 e0       	ldi	r21, 0x00	; 0
 6cc:	61 e0       	ldi	r22, 0x01	; 1
 6ce:	ca 01       	movw	r24, r20
 6d0:	02 2e       	mov	r0, r18
 6d2:	02 c0       	rjmp	.+4      	; 0x6d8 <txlcd+0x1c>
 6d4:	88 0f       	add	r24, r24
 6d6:	99 1f       	adc	r25, r25
 6d8:	0a 94       	dec	r0
 6da:	e2 f7       	brpl	.-8      	; 0x6d4 <txlcd+0x18>
 6dc:	87 ff       	sbrs	r24, 7
 6de:	02 c0       	rjmp	.+4      	; 0x6e4 <txlcd+0x28>
			PORTA |= _BV(PA5);
 6e0:	dd 9a       	sbi	0x1b, 5	; 27
 6e2:	01 c0       	rjmp	.+2      	; 0x6e6 <txlcd+0x2a>
		else
			PORTA &= ~_BV(PA5);
 6e4:	dd 98       	cbi	0x1b, 5	; 27
 6e6:	91 e0       	ldi	r25, 0x01	; 1
 6e8:	86 2f       	mov	r24, r22
 6ea:	8a 95       	dec	r24
 6ec:	f1 f7       	brne	.-4      	; 0x6ea <txlcd+0x2e>
		_delay_us(2);
		PORTA |= _BV(PA4);
 6ee:	dc 9a       	sbi	0x1b, 4	; 27
 6f0:	86 2f       	mov	r24, r22
 6f2:	8a 95       	dec	r24
 6f4:	f1 f7       	brne	.-4      	; 0x6f2 <txlcd+0x36>
		_delay_us(2);
		PORTA &= ~_BV(PA4);
 6f6:	dc 98       	cbi	0x1b, 4	; 27
 6f8:	2f 5f       	subi	r18, 0xFF	; 255
 6fa:	3f 4f       	sbci	r19, 0xFF	; 255
void txlcd(uint8_t b) {
	uint8_t c;

	PORTA &= ~_BV(PA2);
	_delay_us(2);
	for (c=0;c<8;c++) {
 6fc:	28 30       	cpi	r18, 0x08	; 8
 6fe:	31 05       	cpc	r19, r1
 700:	31 f7       	brne	.-52     	; 0x6ce <txlcd+0x12>
 702:	89 2f       	mov	r24, r25
 704:	8a 95       	dec	r24
 706:	f1 f7       	brne	.-4      	; 0x704 <txlcd+0x48>
		PORTA |= _BV(PA4);
		_delay_us(2);
		PORTA &= ~_BV(PA4);
	}
	_delay_us(2);
	PORTA |= _BV(PA2);
 708:	da 9a       	sbi	0x1b, 2	; 27
 70a:	89 2f       	mov	r24, r25
 70c:	8a 95       	dec	r24
 70e:	f1 f7       	brne	.-4      	; 0x70c <txlcd+0x50>
	_delay_us(2);
}
 710:	08 95       	ret

00000712 <clrlcd>:

void clrlcd() {
 712:	1f 93       	push	r17
	uint8_t c;
	PORTA |= 0b00001000;
 714:	db 9a       	sbi	0x1b, 3	; 27
 716:	10 e0       	ldi	r17, 0x00	; 0
	for (c=0;c<252;c++) {
		txlcd(0);
 718:	80 e0       	ldi	r24, 0x00	; 0
 71a:	d0 df       	rcall	.-96     	; 0x6bc <txlcd>
		txlcd(0);
 71c:	80 e0       	ldi	r24, 0x00	; 0
 71e:	ce df       	rcall	.-100    	; 0x6bc <txlcd>
}

void clrlcd() {
	uint8_t c;
	PORTA |= 0b00001000;
	for (c=0;c<252;c++) {
 720:	1f 5f       	subi	r17, 0xFF	; 255
 722:	1c 3f       	cpi	r17, 0xFC	; 252
 724:	c9 f7       	brne	.-14     	; 0x718 <clrlcd+0x6>
		txlcd(0);
		txlcd(0);
	}
}
 726:	1f 91       	pop	r17
 728:	08 95       	ret

0000072a <lcdxy>:
		txlcd(0);
		txt++;
	}
}

void lcdxy(uint8_t x, uint8_t y) {
 72a:	1f 93       	push	r17
 72c:	16 2f       	mov	r17, r22
	PORTA &= ~0b00001000;
 72e:	db 98       	cbi	0x1b, 3	; 27
	txlcd(0x80+x);
 730:	80 58       	subi	r24, 0x80	; 128
 732:	c4 df       	rcall	.-120    	; 0x6bc <txlcd>
	txlcd(0x40+y);
 734:	81 2f       	mov	r24, r17
 736:	80 5c       	subi	r24, 0xC0	; 192
 738:	c1 df       	rcall	.-126    	; 0x6bc <txlcd>
	PORTA |= 0b00001000;
 73a:	db 9a       	sbi	0x1b, 3	; 27
}
 73c:	1f 91       	pop	r17
 73e:	08 95       	ret

00000740 <drawlcd>:

void drawlcd(uint8_t x, uint8_t y, uint8_t s, uint8_t e, uint8_t inv, uint8_t flip) {
 740:	ef 92       	push	r14
 742:	ff 92       	push	r15
 744:	0f 93       	push	r16
 746:	1f 93       	push	r17
 748:	cf 93       	push	r28
 74a:	df 93       	push	r29
 74c:	14 2f       	mov	r17, r20
 74e:	f2 2e       	mov	r15, r18
	uint8_t b;

	lcdxy(x,y);
 750:	ec df       	rcall	.-40     	; 0x72a <lcdxy>
	if (!flip) {
 752:	ee 20       	and	r14, r14
 754:	91 f4       	brne	.+36     	; 0x77a <drawlcd+0x3a>
 756:	e1 2e       	mov	r14, r17
		for (b=s;b<e+s;b++) {
 758:	c1 2f       	mov	r28, r17
 75a:	d0 e0       	ldi	r29, 0x00	; 0
 75c:	cf 0d       	add	r28, r15
 75e:	d1 1d       	adc	r29, r1
 760:	06 c0       	rjmp	.+12     	; 0x76e <drawlcd+0x2e>
			txlcd(eebuf[b] ^ inv);
 762:	eb 59       	subi	r30, 0x9B	; 155
 764:	ff 4f       	sbci	r31, 0xFF	; 255
 766:	80 81       	ld	r24, Z
 768:	80 27       	eor	r24, r16
 76a:	a8 df       	rcall	.-176    	; 0x6bc <txlcd>
void drawlcd(uint8_t x, uint8_t y, uint8_t s, uint8_t e, uint8_t inv, uint8_t flip) {
	uint8_t b;

	lcdxy(x,y);
	if (!flip) {
		for (b=s;b<e+s;b++) {
 76c:	e3 94       	inc	r14
 76e:	ee 2d       	mov	r30, r14
 770:	f0 e0       	ldi	r31, 0x00	; 0
 772:	ec 17       	cp	r30, r28
 774:	fd 07       	cpc	r31, r29
 776:	ac f3       	brlt	.-22     	; 0x762 <drawlcd+0x22>
 778:	0d c0       	rjmp	.+26     	; 0x794 <drawlcd+0x54>
			txlcd(eebuf[b] ^ inv);
		}
	} else {
		for (b=e+s;b>s;b--) {
 77a:	ef 2c       	mov	r14, r15
 77c:	e1 0e       	add	r14, r17
 77e:	08 c0       	rjmp	.+16     	; 0x790 <drawlcd+0x50>
			txlcd(eebuf[b] ^ inv);
 780:	ee 2d       	mov	r30, r14
 782:	f0 e0       	ldi	r31, 0x00	; 0
 784:	eb 59       	subi	r30, 0x9B	; 155
 786:	ff 4f       	sbci	r31, 0xFF	; 255
 788:	80 81       	ld	r24, Z
 78a:	80 27       	eor	r24, r16
 78c:	97 df       	rcall	.-210    	; 0x6bc <txlcd>
	if (!flip) {
		for (b=s;b<e+s;b++) {
			txlcd(eebuf[b] ^ inv);
		}
	} else {
		for (b=e+s;b>s;b--) {
 78e:	ea 94       	dec	r14
 790:	1e 15       	cp	r17, r14
 792:	b0 f3       	brcs	.-20     	; 0x780 <drawlcd+0x40>
			txlcd(eebuf[b] ^ inv);
		}

	}
}
 794:	df 91       	pop	r29
 796:	cf 91       	pop	r28
 798:	1f 91       	pop	r17
 79a:	0f 91       	pop	r16
 79c:	ff 90       	pop	r15
 79e:	ef 90       	pop	r14
 7a0:	08 95       	ret

000007a2 <drawfur>:

void drawfur(uint8_t frame, uint8_t flip) {
 7a2:	cf 92       	push	r12
 7a4:	df 92       	push	r13
 7a6:	ef 92       	push	r14
 7a8:	0f 93       	push	r16
 7aa:	1f 93       	push	r17
 7ac:	c8 2e       	mov	r12, r24
 7ae:	16 2f       	mov	r17, r22
	exee_read_buf(frame);
 7b0:	90 e0       	ldi	r25, 0x00	; 0
 7b2:	2a d1       	rcall	.+596    	; 0xa08 <exee_read_buf>
	drawlcd(xpos,1,0,32,0,flip);
 7b4:	80 91 60 00 	lds	r24, 0x0060
 7b8:	61 e0       	ldi	r22, 0x01	; 1
 7ba:	40 e0       	ldi	r20, 0x00	; 0
 7bc:	20 e2       	ldi	r18, 0x20	; 32
 7be:	00 e0       	ldi	r16, 0x00	; 0
 7c0:	e1 2e       	mov	r14, r17
 7c2:	be df       	rcall	.-132    	; 0x740 <drawlcd>
	drawlcd(xpos,2,32,32,0,flip);
 7c4:	80 91 60 00 	lds	r24, 0x0060
 7c8:	62 e0       	ldi	r22, 0x02	; 2
 7ca:	40 e2       	ldi	r20, 0x20	; 32
 7cc:	20 e2       	ldi	r18, 0x20	; 32
 7ce:	b8 df       	rcall	.-144    	; 0x740 <drawlcd>
	exee_read_buf(frame+1);
 7d0:	dd 24       	eor	r13, r13
 7d2:	c6 01       	movw	r24, r12
 7d4:	01 96       	adiw	r24, 0x01	; 1
 7d6:	18 d1       	rcall	.+560    	; 0xa08 <exee_read_buf>
	drawlcd(xpos,3,0,32,0,flip);
 7d8:	80 91 60 00 	lds	r24, 0x0060
 7dc:	63 e0       	ldi	r22, 0x03	; 3
 7de:	40 e0       	ldi	r20, 0x00	; 0
 7e0:	20 e2       	ldi	r18, 0x20	; 32
 7e2:	ae df       	rcall	.-164    	; 0x740 <drawlcd>
	drawlcd(xpos,4,32,32,0,flip);
 7e4:	80 91 60 00 	lds	r24, 0x0060
 7e8:	64 e0       	ldi	r22, 0x04	; 4
 7ea:	40 e2       	ldi	r20, 0x20	; 32
 7ec:	20 e2       	ldi	r18, 0x20	; 32
 7ee:	a8 df       	rcall	.-176    	; 0x740 <drawlcd>
}
 7f0:	1f 91       	pop	r17
 7f2:	0f 91       	pop	r16
 7f4:	ef 90       	pop	r14
 7f6:	df 90       	pop	r13
 7f8:	cf 90       	pop	r12
 7fa:	08 95       	ret

000007fc <lcdtxt>:
		txlcd(0);
		txlcd(0);
	}
}

void lcdtxt(char *txt) {
 7fc:	ef 92       	push	r14
 7fe:	ff 92       	push	r15
 800:	0f 93       	push	r16
 802:	1f 93       	push	r17
 804:	cf 93       	push	r28
 806:	df 93       	push	r29
 808:	7c 01       	movw	r14, r24
 80a:	29 c0       	rjmp	.+82     	; 0x85e <lcdtxt+0x62>
	uint8_t tc,cv;
	while (*txt) {
		cv = (*txt);
		if (cv == 32) {
 80c:	80 32       	cpi	r24, 0x20	; 32
 80e:	39 f4       	brne	.+14     	; 0x81e <lcdtxt+0x22>
 810:	10 e0       	ldi	r17, 0x00	; 0
			for (tc=0;tc<5;tc++)
				txlcd(0);
 812:	80 e0       	ldi	r24, 0x00	; 0
 814:	53 df       	rcall	.-346    	; 0x6bc <txlcd>
void lcdtxt(char *txt) {
	uint8_t tc,cv;
	while (*txt) {
		cv = (*txt);
		if (cv == 32) {
			for (tc=0;tc<5;tc++)
 816:	1f 5f       	subi	r17, 0xFF	; 255
 818:	15 30       	cpi	r17, 0x05	; 5
 81a:	d9 f7       	brne	.-10     	; 0x812 <lcdtxt+0x16>
 81c:	1b c0       	rjmp	.+54     	; 0x854 <lcdtxt+0x58>
				txlcd(0);
		} else {
			if (cv == 33) {
 81e:	81 32       	cpi	r24, 0x21	; 33
 820:	11 f4       	brne	.+4      	; 0x826 <lcdtxt+0x2a>
 822:	87 e3       	ldi	r24, 0x37	; 55
 824:	09 c0       	rjmp	.+18     	; 0x838 <lcdtxt+0x3c>
				cv = 11*5;
			} else if (cv == 63) {
 826:	8f 33       	cpi	r24, 0x3F	; 63
 828:	11 f4       	brne	.+4      	; 0x82e <lcdtxt+0x32>
 82a:	8c e3       	ldi	r24, 0x3C	; 60
 82c:	05 c0       	rjmp	.+10     	; 0x838 <lcdtxt+0x3c>
				cv = 12*5;
			} else {
				cv = (cv-0x30)*5;
 82e:	90 e0       	ldi	r25, 0x00	; 0
 830:	65 e0       	ldi	r22, 0x05	; 5
 832:	70 e0       	ldi	r23, 0x00	; 0
 834:	12 d1       	rcall	.+548    	; 0xa5a <__mulhi3>
 836:	80 5f       	subi	r24, 0xF0	; 240
 838:	90 e0       	ldi	r25, 0x00	; 0
 83a:	ec 01       	movw	r28, r24
 83c:	c0 58       	subi	r28, 0x80	; 128
 83e:	df 4f       	sbci	r29, 0xFF	; 255
			}
			for (tc=0;tc<5;tc++)
 840:	8c 01       	movw	r16, r24
 842:	0b 57       	subi	r16, 0x7B	; 123
 844:	1f 4f       	sbci	r17, 0xFF	; 255
				txlcd(exee_read_byte(128+cv+tc));
 846:	ce 01       	movw	r24, r28
 848:	cb d0       	rcall	.+406    	; 0x9e0 <exee_read_byte>
 84a:	38 df       	rcall	.-400    	; 0x6bc <txlcd>
 84c:	21 96       	adiw	r28, 0x01	; 1
			} else if (cv == 63) {
				cv = 12*5;
			} else {
				cv = (cv-0x30)*5;
			}
			for (tc=0;tc<5;tc++)
 84e:	c0 17       	cp	r28, r16
 850:	d1 07       	cpc	r29, r17
 852:	c9 f7       	brne	.-14     	; 0x846 <lcdtxt+0x4a>
				txlcd(exee_read_byte(128+cv+tc));
		}
		txlcd(0);
 854:	80 e0       	ldi	r24, 0x00	; 0
 856:	32 df       	rcall	.-412    	; 0x6bc <txlcd>
		txt++;
 858:	08 94       	sec
 85a:	e1 1c       	adc	r14, r1
 85c:	f1 1c       	adc	r15, r1
	}
}

void lcdtxt(char *txt) {
	uint8_t tc,cv;
	while (*txt) {
 85e:	f7 01       	movw	r30, r14
 860:	80 81       	ld	r24, Z
 862:	88 23       	and	r24, r24
 864:	99 f6       	brne	.-90     	; 0x80c <lcdtxt+0x10>
				txlcd(exee_read_byte(128+cv+tc));
		}
		txlcd(0);
		txt++;
	}
}
 866:	df 91       	pop	r29
 868:	cf 91       	pop	r28
 86a:	1f 91       	pop	r17
 86c:	0f 91       	pop	r16
 86e:	ff 90       	pop	r15
 870:	ef 90       	pop	r14
 872:	08 95       	ret

00000874 <i2c_io_set_sda>:
#include <inttypes.h>
#include <avr/pgmspace.h>
#include "exee.h"

void i2c_io_set_sda(uint8_t hi) {
	if (hi) {
 874:	88 23       	and	r24, r24
 876:	11 f0       	breq	.+4      	; 0x87c <i2c_io_set_sda+0x8>
		DDRA &= ~_BV(SDA);
 878:	d7 98       	cbi	0x1a, 7	; 26
 87a:	01 c0       	rjmp	.+2      	; 0x87e <i2c_io_set_sda+0xa>
		PORTA &= ~_BV(SDA);
	} else {
		DDRA |= _BV(SDA);
 87c:	d7 9a       	sbi	0x1a, 7	; 26
		PORTA &= ~_BV(SDA);
 87e:	df 98       	cbi	0x1b, 7	; 27
 880:	08 95       	ret

00000882 <i2c_io_set_scl>:
	}
}

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
 882:	88 23       	and	r24, r24
 884:	11 f0       	breq	.+4      	; 0x88a <i2c_io_set_scl+0x8>
		PORTA |= _BV(SCL);
 886:	dc 9a       	sbi	0x1b, 4	; 27
 888:	08 95       	ret
	else
		PORTA &= ~_BV(SCL);
 88a:	dc 98       	cbi	0x1b, 4	; 27
 88c:	08 95       	ret

0000088e <i2c_start>:
}

void i2c_start() {
 88e:	1f 93       	push	r17
	}
}

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
 890:	dc 9a       	sbi	0x1b, 4	; 27
 892:	11 e0       	ldi	r17, 0x01	; 1
 894:	81 2f       	mov	r24, r17
 896:	8a 95       	dec	r24
 898:	f1 f7       	brne	.-4      	; 0x896 <i2c_start+0x8>
}

void i2c_start() {
  	i2c_io_set_scl(1);
	_delay_us(2);
  	i2c_io_set_sda(0);
 89a:	80 e0       	ldi	r24, 0x00	; 0
 89c:	eb df       	rcall	.-42     	; 0x874 <i2c_io_set_sda>
 89e:	1a 95       	dec	r17
 8a0:	f1 f7       	brne	.-4      	; 0x89e <i2c_start+0x10>

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
	else
		PORTA &= ~_BV(SCL);
 8a2:	dc 98       	cbi	0x1b, 4	; 27
 8a4:	83 e0       	ldi	r24, 0x03	; 3
 8a6:	8a 95       	dec	r24
 8a8:	f1 f7       	brne	.-4      	; 0x8a6 <i2c_start+0x18>
	_delay_us(2);
  	i2c_io_set_sda(0);
	_delay_us(2);
  	i2c_io_set_scl(0);
	_delay_us(10);
}
 8aa:	1f 91       	pop	r17
 8ac:	08 95       	ret

000008ae <i2c_stop>:

void i2c_stop() {
 8ae:	1f 93       	push	r17
 8b0:	11 e0       	ldi	r17, 0x01	; 1
 8b2:	81 2f       	mov	r24, r17
 8b4:	8a 95       	dec	r24
 8b6:	f1 f7       	brne	.-4      	; 0x8b4 <i2c_stop+0x6>

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
	else
		PORTA &= ~_BV(SCL);
 8b8:	dc 98       	cbi	0x1b, 4	; 27
 8ba:	81 2f       	mov	r24, r17
 8bc:	8a 95       	dec	r24
 8be:	f1 f7       	brne	.-4      	; 0x8bc <i2c_stop+0xe>

void i2c_stop() {
	_delay_us(2);
  	i2c_io_set_scl(0);
	_delay_us(2);
  	i2c_io_set_sda(0);
 8c0:	80 e0       	ldi	r24, 0x00	; 0
 8c2:	d8 df       	rcall	.-80     	; 0x874 <i2c_io_set_sda>
 8c4:	81 2f       	mov	r24, r17
 8c6:	8a 95       	dec	r24
 8c8:	f1 f7       	brne	.-4      	; 0x8c6 <i2c_stop+0x18>
	}
}

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
 8ca:	dc 9a       	sbi	0x1b, 4	; 27
 8cc:	1a 95       	dec	r17
 8ce:	f1 f7       	brne	.-4      	; 0x8cc <i2c_stop+0x1e>
	_delay_us(2);
  	i2c_io_set_sda(0);
	_delay_us(2);
  	i2c_io_set_scl(1);
	_delay_us(2);
  	i2c_io_set_sda(1);
 8d0:	81 e0       	ldi	r24, 0x01	; 1
 8d2:	d0 df       	rcall	.-96     	; 0x874 <i2c_io_set_sda>
}
 8d4:	1f 91       	pop	r17
 8d6:	08 95       	ret

000008d8 <i2c_write>:

uint8_t i2c_write(uint8_t byte) {
 8d8:	ef 92       	push	r14
 8da:	ff 92       	push	r15
 8dc:	1f 93       	push	r17
 8de:	cf 93       	push	r28
 8e0:	df 93       	push	r29
 8e2:	c0 e0       	ldi	r28, 0x00	; 0
 8e4:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t ack, bit;

	for (bit=0;bit<8;bit++) {
		if (((byte<<bit) & 0x80) == 0x80)
 8e6:	e8 2e       	mov	r14, r24
 8e8:	ff 24       	eor	r15, r15
 8ea:	c7 01       	movw	r24, r14
 8ec:	0c 2e       	mov	r0, r28
 8ee:	02 c0       	rjmp	.+4      	; 0x8f4 <i2c_write+0x1c>
 8f0:	88 0f       	add	r24, r24
 8f2:	99 1f       	adc	r25, r25
 8f4:	0a 94       	dec	r0
 8f6:	e2 f7       	brpl	.-8      	; 0x8f0 <i2c_write+0x18>
 8f8:	87 ff       	sbrs	r24, 7
 8fa:	02 c0       	rjmp	.+4      	; 0x900 <i2c_write+0x28>
			i2c_io_set_sda(1);
 8fc:	81 e0       	ldi	r24, 0x01	; 1
 8fe:	01 c0       	rjmp	.+2      	; 0x902 <i2c_write+0x2a>
		else
			i2c_io_set_sda(0);
 900:	80 e0       	ldi	r24, 0x00	; 0
 902:	b8 df       	rcall	.-144    	; 0x874 <i2c_io_set_sda>
 904:	11 e0       	ldi	r17, 0x01	; 1
 906:	81 2f       	mov	r24, r17
 908:	8a 95       	dec	r24
 90a:	f1 f7       	brne	.-4      	; 0x908 <i2c_write+0x30>
	}
}

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
 90c:	dc 9a       	sbi	0x1b, 4	; 27
 90e:	81 2f       	mov	r24, r17
 910:	8a 95       	dec	r24
 912:	f1 f7       	brne	.-4      	; 0x910 <i2c_write+0x38>
	else
		PORTA &= ~_BV(SCL);
 914:	dc 98       	cbi	0x1b, 4	; 27
 916:	21 96       	adiw	r28, 0x01	; 1
}

uint8_t i2c_write(uint8_t byte) {
	uint8_t ack, bit;

	for (bit=0;bit<8;bit++) {
 918:	c8 30       	cpi	r28, 0x08	; 8
 91a:	d1 05       	cpc	r29, r1
 91c:	31 f7       	brne	.-52     	; 0x8ea <i2c_write+0x12>
		_delay_us(2);
  		i2c_io_set_scl(1);
		_delay_us(2);
  		i2c_io_set_scl(0);
	}
	i2c_io_set_sda(1);
 91e:	81 e0       	ldi	r24, 0x01	; 1
 920:	a9 df       	rcall	.-174    	; 0x874 <i2c_io_set_sda>
 922:	81 2f       	mov	r24, r17
 924:	8a 95       	dec	r24
 926:	f1 f7       	brne	.-4      	; 0x924 <i2c_write+0x4c>
	}
}

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
 928:	dc 9a       	sbi	0x1b, 4	; 27
 92a:	81 2f       	mov	r24, r17
 92c:	8a 95       	dec	r24
 92e:	f1 f7       	brne	.-4      	; 0x92c <i2c_write+0x54>
	i2c_io_set_sda(1);
	_delay_us(5);

  	i2c_io_set_scl(1);
	_delay_us(2);
	ack = (PINA & SDA)>>SDA;
 930:	89 b3       	in	r24, 0x19	; 25
 932:	81 2f       	mov	r24, r17
 934:	8a 95       	dec	r24
 936:	f1 f7       	brne	.-4      	; 0x934 <i2c_write+0x5c>

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
	else
		PORTA &= ~_BV(SCL);
 938:	dc 98       	cbi	0x1b, 4	; 27
 93a:	81 2f       	mov	r24, r17
 93c:	8a 95       	dec	r24
 93e:	f1 f7       	brne	.-4      	; 0x93c <i2c_write+0x64>
	ack = (PINA & SDA)>>SDA;
	_delay_us(2);
  	i2c_io_set_scl(0);
	_delay_us(2);
	return ack;
}
 940:	80 e0       	ldi	r24, 0x00	; 0
 942:	df 91       	pop	r29
 944:	cf 91       	pop	r28
 946:	1f 91       	pop	r17
 948:	ff 90       	pop	r15
 94a:	ef 90       	pop	r14
 94c:	08 95       	ret

0000094e <i2c_read>:

uint8_t i2c_read() {
 94e:	0f 93       	push	r16
 950:	1f 93       	push	r17
 952:	10 e0       	ldi	r17, 0x00	; 0
 954:	00 e0       	ldi	r16, 0x00	; 0
	uint8_t byte = 0x00, bit;
	for (bit=0;bit<8;bit++) {
  		i2c_io_set_sda(1);
 956:	81 e0       	ldi	r24, 0x01	; 1
 958:	8d df       	rcall	.-230    	; 0x874 <i2c_io_set_sda>

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
	else
		PORTA &= ~_BV(SCL);
 95a:	dc 98       	cbi	0x1b, 4	; 27
 95c:	81 e0       	ldi	r24, 0x01	; 1
 95e:	98 2f       	mov	r25, r24
 960:	9a 95       	dec	r25
 962:	f1 f7       	brne	.-4      	; 0x960 <i2c_read+0x12>
	}
}

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
 964:	dc 9a       	sbi	0x1b, 4	; 27
 966:	8a 95       	dec	r24
 968:	f1 f7       	brne	.-4      	; 0x966 <i2c_read+0x18>
  		i2c_io_set_sda(1);
    	i2c_io_set_scl(0);
		_delay_us(2);
    	i2c_io_set_scl(1);
		_delay_us(2);
		byte <<= 1;
 96a:	11 0f       	add	r17, r17
    	if (PINA & _BV(SDA)) byte |= 1;
 96c:	cf 99       	sbic	0x19, 7	; 25
 96e:	11 60       	ori	r17, 0x01	; 1
 970:	81 e0       	ldi	r24, 0x01	; 1
 972:	8a 95       	dec	r24
 974:	f1 f7       	brne	.-4      	; 0x972 <i2c_read+0x24>

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
	else
		PORTA &= ~_BV(SCL);
 976:	dc 98       	cbi	0x1b, 4	; 27
	return ack;
}

uint8_t i2c_read() {
	uint8_t byte = 0x00, bit;
	for (bit=0;bit<8;bit++) {
 978:	0f 5f       	subi	r16, 0xFF	; 255
 97a:	08 30       	cpi	r16, 0x08	; 8
 97c:	61 f7       	brne	.-40     	; 0x956 <i2c_read+0x8>
    	if (PINA & _BV(SDA)) byte |= 1;
		_delay_us(1);
    	i2c_io_set_scl(0);
	}
	return byte;
}
 97e:	81 2f       	mov	r24, r17
 980:	1f 91       	pop	r17
 982:	0f 91       	pop	r16
 984:	08 95       	ret

00000986 <i2c_readack>:

void i2c_readack() {
 986:	1f 93       	push	r17

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
	else
		PORTA &= ~_BV(SCL);
 988:	dc 98       	cbi	0x1b, 4	; 27
 98a:	11 e0       	ldi	r17, 0x01	; 1
 98c:	81 2f       	mov	r24, r17
 98e:	8a 95       	dec	r24
 990:	f1 f7       	brne	.-4      	; 0x98e <i2c_readack+0x8>
}

void i2c_readack() {
   	i2c_io_set_scl(0);
	_delay_us(2);
  	i2c_io_set_sda(0);
 992:	80 e0       	ldi	r24, 0x00	; 0
 994:	6f df       	rcall	.-290    	; 0x874 <i2c_io_set_sda>
 996:	81 2f       	mov	r24, r17
 998:	8a 95       	dec	r24
 99a:	f1 f7       	brne	.-4      	; 0x998 <i2c_readack+0x12>
	}
}

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
 99c:	dc 9a       	sbi	0x1b, 4	; 27
 99e:	81 2f       	mov	r24, r17
 9a0:	8a 95       	dec	r24
 9a2:	f1 f7       	brne	.-4      	; 0x9a0 <i2c_readack+0x1a>
	else
		PORTA &= ~_BV(SCL);
 9a4:	dc 98       	cbi	0x1b, 4	; 27
 9a6:	81 2f       	mov	r24, r17
 9a8:	8a 95       	dec	r24
 9aa:	f1 f7       	brne	.-4      	; 0x9a8 <i2c_readack+0x22>
	_delay_us(2);
   	i2c_io_set_scl(1);
	_delay_us(2);
   	i2c_io_set_scl(0);
	_delay_us(2);
  	i2c_io_set_sda(1);
 9ac:	81 e0       	ldi	r24, 0x01	; 1
 9ae:	62 df       	rcall	.-316    	; 0x874 <i2c_io_set_sda>
 9b0:	1a 95       	dec	r17
 9b2:	f1 f7       	brne	.-4      	; 0x9b0 <i2c_readack+0x2a>
	_delay_us(2);
}
 9b4:	1f 91       	pop	r17
 9b6:	08 95       	ret

000009b8 <i2c_noreadack>:

void i2c_noreadack() {
 9b8:	1f 93       	push	r17

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
	else
		PORTA &= ~_BV(SCL);
 9ba:	dc 98       	cbi	0x1b, 4	; 27
 9bc:	11 e0       	ldi	r17, 0x01	; 1
 9be:	81 2f       	mov	r24, r17
 9c0:	8a 95       	dec	r24
 9c2:	f1 f7       	brne	.-4      	; 0x9c0 <i2c_noreadack+0x8>
}

void i2c_noreadack() {
   	i2c_io_set_scl(0);
	_delay_us(2);
  	i2c_io_set_sda(1);
 9c4:	81 e0       	ldi	r24, 0x01	; 1
 9c6:	56 df       	rcall	.-340    	; 0x874 <i2c_io_set_sda>
 9c8:	81 2f       	mov	r24, r17
 9ca:	8a 95       	dec	r24
 9cc:	f1 f7       	brne	.-4      	; 0x9ca <i2c_noreadack+0x12>
	}
}

void i2c_io_set_scl(uint8_t hi) {
	if (hi)
		PORTA |= _BV(SCL);
 9ce:	dc 9a       	sbi	0x1b, 4	; 27
 9d0:	81 2f       	mov	r24, r17
 9d2:	8a 95       	dec	r24
 9d4:	f1 f7       	brne	.-4      	; 0x9d2 <i2c_noreadack+0x1a>
	else
		PORTA &= ~_BV(SCL);
 9d6:	dc 98       	cbi	0x1b, 4	; 27
 9d8:	1a 95       	dec	r17
 9da:	f1 f7       	brne	.-4      	; 0x9d8 <i2c_noreadack+0x20>
	_delay_us(2);
   	i2c_io_set_scl(1);
	_delay_us(2);
   	i2c_io_set_scl(0);
	_delay_us(5);
}
 9dc:	1f 91       	pop	r17
 9de:	08 95       	ret

000009e0 <exee_read_byte>:

uint8_t exee_read_byte(uint16_t addr) {
 9e0:	0f 93       	push	r16
 9e2:	1f 93       	push	r17
 9e4:	8c 01       	movw	r16, r24
	uint8_t v;
	i2c_start();
 9e6:	53 df       	rcall	.-346    	; 0x88e <i2c_start>
	i2c_write(0xA0);
 9e8:	80 ea       	ldi	r24, 0xA0	; 160
 9ea:	76 df       	rcall	.-276    	; 0x8d8 <i2c_write>
	i2c_write(addr>>8);
 9ec:	81 2f       	mov	r24, r17
 9ee:	74 df       	rcall	.-280    	; 0x8d8 <i2c_write>
	i2c_write(addr & 0xFF);
 9f0:	80 2f       	mov	r24, r16
 9f2:	72 df       	rcall	.-284    	; 0x8d8 <i2c_write>
	i2c_start();
 9f4:	4c df       	rcall	.-360    	; 0x88e <i2c_start>
	i2c_write(0xA1);
 9f6:	81 ea       	ldi	r24, 0xA1	; 161
 9f8:	6f df       	rcall	.-290    	; 0x8d8 <i2c_write>
	v = i2c_read();
 9fa:	a9 df       	rcall	.-174    	; 0x94e <i2c_read>
 9fc:	18 2f       	mov	r17, r24
	i2c_noreadack();
 9fe:	dc df       	rcall	.-72     	; 0x9b8 <i2c_noreadack>
	return v;
}
 a00:	81 2f       	mov	r24, r17
 a02:	1f 91       	pop	r17
 a04:	0f 91       	pop	r16
 a06:	08 95       	ret

00000a08 <exee_read_buf>:

uint8_t eebuf[64];

void exee_read_buf(uint16_t addr) {
 a08:	0f 93       	push	r16
 a0a:	1f 93       	push	r17
 a0c:	cf 93       	push	r28
 a0e:	df 93       	push	r29
	uint8_t c;

	addr *= 64;
 a10:	8c 01       	movw	r16, r24
 a12:	86 e0       	ldi	r24, 0x06	; 6
 a14:	00 0f       	add	r16, r16
 a16:	11 1f       	adc	r17, r17
 a18:	8a 95       	dec	r24
 a1a:	e1 f7       	brne	.-8      	; 0xa14 <exee_read_buf+0xc>
	i2c_start();
 a1c:	38 df       	rcall	.-400    	; 0x88e <i2c_start>
	i2c_write(0xA0);
 a1e:	80 ea       	ldi	r24, 0xA0	; 160
 a20:	5b df       	rcall	.-330    	; 0x8d8 <i2c_write>
	i2c_write(addr>>8);
 a22:	81 2f       	mov	r24, r17
 a24:	59 df       	rcall	.-334    	; 0x8d8 <i2c_write>
	i2c_write(addr & 0xFF);
 a26:	80 2f       	mov	r24, r16
 a28:	57 df       	rcall	.-338    	; 0x8d8 <i2c_write>
	i2c_start();
 a2a:	31 df       	rcall	.-414    	; 0x88e <i2c_start>
	i2c_write(0xA1);
 a2c:	81 ea       	ldi	r24, 0xA1	; 161
 a2e:	54 df       	rcall	.-344    	; 0x8d8 <i2c_write>
 a30:	c0 e0       	ldi	r28, 0x00	; 0
 a32:	d0 e0       	ldi	r29, 0x00	; 0
	for (c=0;c<64;c++) {
		eebuf[c] = i2c_read();
 a34:	8c df       	rcall	.-232    	; 0x94e <i2c_read>
 a36:	fe 01       	movw	r30, r28
 a38:	eb 59       	subi	r30, 0x9B	; 155
 a3a:	ff 4f       	sbci	r31, 0xFF	; 255
 a3c:	80 83       	st	Z, r24
		if (c == 63)
 a3e:	cf 33       	cpi	r28, 0x3F	; 63
 a40:	11 f4       	brne	.+4      	; 0xa46 <exee_read_buf+0x3e>
			i2c_noreadack();
 a42:	ba df       	rcall	.-140    	; 0x9b8 <i2c_noreadack>
 a44:	01 c0       	rjmp	.+2      	; 0xa48 <exee_read_buf+0x40>
		else
			i2c_readack();
 a46:	9f df       	rcall	.-194    	; 0x986 <i2c_readack>
 a48:	21 96       	adiw	r28, 0x01	; 1
	i2c_write(0xA0);
	i2c_write(addr>>8);
	i2c_write(addr & 0xFF);
	i2c_start();
	i2c_write(0xA1);
	for (c=0;c<64;c++) {
 a4a:	c0 34       	cpi	r28, 0x40	; 64
 a4c:	d1 05       	cpc	r29, r1
 a4e:	91 f7       	brne	.-28     	; 0xa34 <exee_read_buf+0x2c>
		if (c == 63)
			i2c_noreadack();
		else
			i2c_readack();
	}
}
 a50:	df 91       	pop	r29
 a52:	cf 91       	pop	r28
 a54:	1f 91       	pop	r17
 a56:	0f 91       	pop	r16
 a58:	08 95       	ret

00000a5a <__mulhi3>:
 a5a:	55 27       	eor	r21, r21
 a5c:	00 24       	eor	r0, r0

00000a5e <__mulhi3_loop>:
 a5e:	80 ff       	sbrs	r24, 0
 a60:	02 c0       	rjmp	.+4      	; 0xa66 <__mulhi3_skip1>
 a62:	06 0e       	add	r0, r22
 a64:	57 1f       	adc	r21, r23

00000a66 <__mulhi3_skip1>:
 a66:	66 0f       	add	r22, r22
 a68:	77 1f       	adc	r23, r23
 a6a:	61 15       	cp	r22, r1
 a6c:	71 05       	cpc	r23, r1
 a6e:	21 f0       	breq	.+8      	; 0xa78 <__mulhi3_exit>
 a70:	96 95       	lsr	r25
 a72:	87 95       	ror	r24
 a74:	00 97       	sbiw	r24, 0x00	; 0
 a76:	99 f7       	brne	.-26     	; 0xa5e <__mulhi3_loop>

00000a78 <__mulhi3_exit>:
 a78:	95 2f       	mov	r25, r21
 a7a:	80 2d       	mov	r24, r0
 a7c:	08 95       	ret

00000a7e <_exit>:
 a7e:	f8 94       	cli

00000a80 <__stop_program>:
 a80:	ff cf       	rjmp	.-2      	; 0xa80 <__stop_program>
